Expression
  = FunctionCall
  / BinaryExpression

FunctionCall
  = name:[a-z]+ "(" args:CommaSeparatedList ")" {
      return {
        type: "FunctionCall",
        name: name.join(""),
        args: args.args
      }
    }

BinaryExpression
  = head:Factor tail:(_ ("+" / "-" / "*" / "/" / "<>") _ Factor)* {
      return tail.reduce(function(result, element) {
        const left = result;
        const right = element[3];
        const rawOp = element[1];
        const oper = rawOp === "+" ? "ADD" : rawOp === "-" ? "MINUS" : rawOp === "*" ? "MULTIPLY" : rawOp === "/" ? "DIVIDE" : rawOp === "<>" ? "CONCAT" : "Else";
          return {
            type: "BinaryExpression",
            operator: oper,
            left: result,
            right: right
          }
      }, head);
    }

CommaSeparatedList
  = head:Expression tail:(_ (",") _ Expression)* {
        return {
            type: "CommaSeparatedList",
            args: [head, ...tail.map(l => l[3])]
          }
    }

Factor
  = "(" _ expr:BinaryExpression _ ")" { return expr; }
  / String
  / Float
  / Integer
  / Variable

Integer "integer"
  = _ [0-9]+ {
      return {
        type: "Literal",
        value: parseInt(text(), 10)
      }
    }

Variable "variable"
  = _ [A-Z]+[0-9]+ {
      return {
        type: "Variable",
        value: Number.isNaN(Number(text())) ? text() : Number(text())
      }
    }

Float "float"
  = _ [0-9]+"."[0-9]+ {
      return {
        type: "Literal",
        value: parseFloat(text(), 10)
      }
    }

_ "whitespace"
  = [ \t\n\r]*


String "string"
  = "'" chars:char* "'" { return {
    type: "Literal",
    value: chars.join("")
  } }
  / '"' chars:char* '"' { return {
    type: "Literal",
    value: chars.join("")
  } }

char
  = [^\0-\x1F\x22\x5C\x27]
  / "\\"
    sequence:(
        '"'
      / "'"
      / "\\"
      / "/"
      / "b" { return "\b"; }
      / "f" { return "\f"; }
      / "n" { return "\n"; }
      / "r" { return "\r"; }
      / "t" { return "\t"; }
      / "u" digits:$([0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return {
      type: "Literal",
      value: sequence
    }
  }
 
