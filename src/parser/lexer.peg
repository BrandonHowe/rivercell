{
    const operToName = {
        "+": "ADD",
        "-": "MINUS",
        "*": "MULTIPLY",
        "/": "DIVIDE",
        "^": "POW",
        "%": "MOD",
        "<>": "CONCAT",
        "==": "EQUAL",
        ">=": "GREQUAL",
        ">": "GREATER",
        "<": "LESS",
        "<=": "LEQUAL",
        "!=": "NOTEQUAL",
    }
    const infixes = {
        ">>=": "BIND"
    }
}

Program
  = body:SourceElements? {
      return {
        type: "Program",
        body: body !== null ? body : []
      };
    }

SourceElements
  = head:Expression tail:(_ Expression)* {
      return [head, ...tail.map(l => l[1])];
    }

Expression
  = FunctionCall
  / InfixExpression
  / ConditionalExpression
  / BinaryExpression

FunctionCall
  = name:[a-z]+ "(" args:CommaSeparatedList ")" {
      return {
        type: "FunctionCall",
        name: name.join(""),
        args: args.args
      }
    }

InfixOperator
  = ">>="

InfixExpression
  = left:Factor _ operator:InfixOperator right:CommaSeparatedList {
      return {
        type: "InfixExpression",
        operator: infixes[operator],
        args: [left, ...right.args]
      }
    }

ConditionalExpression
  = condition:BinaryExpression  _ "?" success:Expression _ ":" failure:Expression {
      return {
        type: "ConditionalExpression",
        condition,
        success,
        failure
      }
    }

BinaryOperator
  = "+"
  / "-"
  / "*"
  / "/"
  / "^"
  / "%"
  / "<>"
  / "=="
  / ">="
  / "<="
  / ">"
  / "<"
  / "=="

BinaryExpression
  = head:Factor tail:(_ BinaryOperator _ Factor)* {
      return tail.reduce(function(result, element) {
        const left = result;
        const right = element[3];
        const rawOp = element[1];
        const oper = operToName[rawOp];
          return {
            type: "BinaryExpression",
            operator: oper,
            left: result,
            right: right
          }
      }, head);
    }

CommaSeparatedList
  = head:Expression tail:(_ (",") _ Expression)* {
        return {
            type: "CommaSeparatedList",
            args: [head, ...tail.map(l => l[3])]
          }
    }

Factor
  = "(" _ expr:BinaryExpression _ ")" { return expr; }
  / String
  / Number
  / Boolean
  / CellRange
  / Variable

Number
  = Integer
  / Float

Integer "integer"
  = _ [0-9]+ {
      return {
        type: "NumberLiteral",
        value: parseInt(text(), 10)
      }
    }

Float "float"
  = _ [0-9]+"."[0-9]+ {
      return {
        type: "NumberLiteral",
        value: parseFloat(text(), 10)
      }
    }

String "string"
  = "'" chars:char* "'" { return {
    type: "StringLiteral",
    value: chars.join("")
  } }
  / '"' chars:char* '"' { return {
    type: "StringLiteral",
    value: chars.join("")
  } }

Boolean
  = "true" { return {type: "BooleanLiteral", value: true} }
  / "false" { return {type: "BooleanLiteral", value: false} }

CellRange
  = start:Variable ":" end:Variable {
      return {
        type: "CellRange",
        start,
        end
      }
    }

Variable "variable"
  = _ [A-Z]+[0-9]+ {
      return {
        type: "Variable",
        value: Number.isNaN(Number(text())) ? text() : Number(text())
      }
    }

_ "whitespace"
  = [ \t\n\r]*

char
  = [^\0-\x1F\x22\x5C\x27]
  / "\\"
    sequence:(
        '"'
      / "'"
      / "\\"
      / "/"
      / "b" { return "\b"; }
      / "f" { return "\f"; }
      / "n" { return "\n"; }
      / "r" { return "\r"; }
      / "t" { return "\t"; }
      / "u" digits:$([0-9a-f]i [0-9a-f]i [0-9a-f]i [0-9a-f]i) {
          return String.fromCharCode(parseInt(digits, 16));
        }
    )
    { return {
      type: "Literal",
      value: sequence
    }
  }
 
